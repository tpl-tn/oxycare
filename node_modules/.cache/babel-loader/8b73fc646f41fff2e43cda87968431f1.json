{"ast":null,"code":"'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [ReferenceError, TypeError, RangeError];\nvar enabled = false;\nexports.disable = disable;\n\nfunction disable() {\n  enabled = false;\n  Promise._Y = null;\n  Promise._Z = null;\n}\n\nexports.enable = enable;\n\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n\n  Promise._Y = function (promise) {\n    if (promise._V === 2 && // IS REJECTED\n    rejections[promise._1]) {\n      if (rejections[promise._1].logged) {\n        onHandled(promise._1);\n      } else {\n        clearTimeout(rejections[promise._1].timeout);\n      }\n\n      delete rejections[promise._1];\n    }\n  };\n\n  Promise._Z = function (promise, err) {\n    if (promise._U === 0) {\n      // not yet handled\n      promise._1 = id++;\n      rejections[promise._1] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(onUnhandled.bind(null, promise._1), // For reference errors and type errors, this almost always\n        // means the programmer made a mistake, so log them after just\n        // 100ms\n        // otherwise, wait 2 seconds to see if they get handled\n        matchWhitelist(err, DEFAULT_WHITELIST) ? 100 : 2000),\n        logged: false\n      };\n    }\n  };\n\n  function onUnhandled(id) {\n    if (options.allRejections || matchWhitelist(rejections[id].error, options.whitelist || DEFAULT_WHITELIST)) {\n      rejections[id].displayId = displayId++;\n\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(rejections[id].displayId, rejections[id].error);\n      } else {\n        rejections[id].logged = true;\n        logError(rejections[id].displayId, rejections[id].error);\n      }\n    }\n  }\n\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn('Promise Rejection Handled (id: ' + rejections[id].displayId + '):');\n        console.warn('  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' + rejections[id].displayId + '.');\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}","map":{"version":3,"sources":["/home/mohamed/Desktop/projects/oxycare/node_modules/promise/lib/rejection-tracking.js"],"names":["Promise","require","DEFAULT_WHITELIST","ReferenceError","TypeError","RangeError","enabled","exports","disable","_Y","_Z","enable","options","id","displayId","rejections","promise","_V","_1","logged","onHandled","clearTimeout","timeout","err","_U","error","setTimeout","onUnhandled","bind","matchWhitelist","allRejections","whitelist","logError","console","warn","errStr","stack","split","forEach","line","list","some","cls"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,QAAD,CAArB;;AAEA,IAAIC,iBAAiB,GAAG,CACtBC,cADsB,EAEtBC,SAFsB,EAGtBC,UAHsB,CAAxB;AAMA,IAAIC,OAAO,GAAG,KAAd;AACAC,OAAO,CAACC,OAAR,GAAkBA,OAAlB;;AACA,SAASA,OAAT,GAAmB;AACjBF,EAAAA,OAAO,GAAG,KAAV;AACAN,EAAAA,OAAO,CAACS,EAAR,GAAa,IAAb;AACAT,EAAAA,OAAO,CAACU,EAAR,GAAa,IAAb;AACD;;AAEDH,OAAO,CAACI,MAAR,GAAiBA,MAAjB;;AACA,SAASA,MAAT,CAAgBC,OAAhB,EAAyB;AACvBA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIN,OAAJ,EAAaE,OAAO;AACpBF,EAAAA,OAAO,GAAG,IAAV;AACA,MAAIO,EAAE,GAAG,CAAT;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,UAAU,GAAG,EAAjB;;AACAf,EAAAA,OAAO,CAACS,EAAR,GAAa,UAAUO,OAAV,EAAmB;AAC9B,QACEA,OAAO,CAACC,EAAR,KAAe,CAAf,IAAoB;AACpBF,IAAAA,UAAU,CAACC,OAAO,CAACE,EAAT,CAFZ,EAGE;AACA,UAAIH,UAAU,CAACC,OAAO,CAACE,EAAT,CAAV,CAAuBC,MAA3B,EAAmC;AACjCC,QAAAA,SAAS,CAACJ,OAAO,CAACE,EAAT,CAAT;AACD,OAFD,MAEO;AACLG,QAAAA,YAAY,CAACN,UAAU,CAACC,OAAO,CAACE,EAAT,CAAV,CAAuBI,OAAxB,CAAZ;AACD;;AACD,aAAOP,UAAU,CAACC,OAAO,CAACE,EAAT,CAAjB;AACD;AACF,GAZD;;AAaAlB,EAAAA,OAAO,CAACU,EAAR,GAAa,UAAUM,OAAV,EAAmBO,GAAnB,EAAwB;AACnC,QAAIP,OAAO,CAACQ,EAAR,KAAe,CAAnB,EAAsB;AAAE;AACtBR,MAAAA,OAAO,CAACE,EAAR,GAAaL,EAAE,EAAf;AACAE,MAAAA,UAAU,CAACC,OAAO,CAACE,EAAT,CAAV,GAAyB;AACvBJ,QAAAA,SAAS,EAAE,IADY;AAEvBW,QAAAA,KAAK,EAAEF,GAFgB;AAGvBD,QAAAA,OAAO,EAAEI,UAAU,CACjBC,WAAW,CAACC,IAAZ,CAAiB,IAAjB,EAAuBZ,OAAO,CAACE,EAA/B,CADiB,EAEjB;AACA;AACA;AACA;AACAW,QAAAA,cAAc,CAACN,GAAD,EAAMrB,iBAAN,CAAd,GACI,GADJ,GAEI,IARa,CAHI;AAavBiB,QAAAA,MAAM,EAAE;AAbe,OAAzB;AAeD;AACF,GAnBD;;AAoBA,WAASQ,WAAT,CAAqBd,EAArB,EAAyB;AACvB,QACED,OAAO,CAACkB,aAAR,IACAD,cAAc,CACZd,UAAU,CAACF,EAAD,CAAV,CAAeY,KADH,EAEZb,OAAO,CAACmB,SAAR,IAAqB7B,iBAFT,CAFhB,EAME;AACAa,MAAAA,UAAU,CAACF,EAAD,CAAV,CAAeC,SAAf,GAA2BA,SAAS,EAApC;;AACA,UAAIF,OAAO,CAACe,WAAZ,EAAyB;AACvBZ,QAAAA,UAAU,CAACF,EAAD,CAAV,CAAeM,MAAf,GAAwB,IAAxB;AACAP,QAAAA,OAAO,CAACe,WAAR,CACEZ,UAAU,CAACF,EAAD,CAAV,CAAeC,SADjB,EAEEC,UAAU,CAACF,EAAD,CAAV,CAAeY,KAFjB;AAID,OAND,MAMO;AACLV,QAAAA,UAAU,CAACF,EAAD,CAAV,CAAeM,MAAf,GAAwB,IAAxB;AACAa,QAAAA,QAAQ,CACNjB,UAAU,CAACF,EAAD,CAAV,CAAeC,SADT,EAENC,UAAU,CAACF,EAAD,CAAV,CAAeY,KAFT,CAAR;AAID;AACF;AACF;;AACD,WAASL,SAAT,CAAmBP,EAAnB,EAAuB;AACrB,QAAIE,UAAU,CAACF,EAAD,CAAV,CAAeM,MAAnB,EAA2B;AACzB,UAAIP,OAAO,CAACQ,SAAZ,EAAuB;AACrBR,QAAAA,OAAO,CAACQ,SAAR,CAAkBL,UAAU,CAACF,EAAD,CAAV,CAAeC,SAAjC,EAA4CC,UAAU,CAACF,EAAD,CAAV,CAAeY,KAA3D;AACD,OAFD,MAEO,IAAI,CAACV,UAAU,CAACF,EAAD,CAAV,CAAec,WAApB,EAAiC;AACtCM,QAAAA,OAAO,CAACC,IAAR,CACE,oCAAoCnB,UAAU,CAACF,EAAD,CAAV,CAAeC,SAAnD,GAA+D,IADjE;AAGAmB,QAAAA,OAAO,CAACC,IAAR,CACE,kHACAnB,UAAU,CAACF,EAAD,CAAV,CAAeC,SADf,GAC2B,GAF7B;AAID;AACF;AACF;AACF;;AAED,SAASkB,QAAT,CAAkBnB,EAAlB,EAAsBY,KAAtB,EAA6B;AAC3BQ,EAAAA,OAAO,CAACC,IAAR,CAAa,+CAA+CrB,EAA/C,GAAoD,IAAjE;AACA,MAAIsB,MAAM,GAAG,CAACV,KAAK,KAAKA,KAAK,CAACW,KAAN,IAAeX,KAApB,CAAN,IAAoC,EAAjD;AACAU,EAAAA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,OAAnB,CAA2B,UAAUC,IAAV,EAAgB;AACzCN,IAAAA,OAAO,CAACC,IAAR,CAAa,OAAOK,IAApB;AACD,GAFD;AAGD;;AAED,SAASV,cAAT,CAAwBJ,KAAxB,EAA+Be,IAA/B,EAAqC;AACnC,SAAOA,IAAI,CAACC,IAAL,CAAU,UAAUC,GAAV,EAAe;AAC9B,WAAOjB,KAAK,YAAYiB,GAAxB;AACD,GAFM,CAAP;AAGD","sourcesContent":["'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._Y = null;\n  Promise._Z = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._Y = function (promise) {\n    if (\n      promise._V === 2 && // IS REJECTED\n      rejections[promise._1]\n    ) {\n      if (rejections[promise._1].logged) {\n        onHandled(promise._1);\n      } else {\n        clearTimeout(rejections[promise._1].timeout);\n      }\n      delete rejections[promise._1];\n    }\n  };\n  Promise._Z = function (promise, err) {\n    if (promise._U === 0) { // not yet handled\n      promise._1 = id++;\n      rejections[promise._1] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._1),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}"]},"metadata":{},"sourceType":"script"}
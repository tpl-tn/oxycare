{"ast":null,"code":"import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext, useStore } from 'react-redux';\nimport invariant from 'invariant';\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport conformsTo from 'lodash/conformsTo';\nimport isObject from 'lodash/isObject';\n/**\n * Forces a reload of the injected reducers. i.e. Causes `createReducer` to be\n * called again with the injected reducers. Useful for hot-reloading.\n *\n * @param store The redux store that has been configured with\n *                  `createInjectorsEnhancer`\n * @example\n * forceReducerReload(store);\n *\n * @public\n */\n\nfunction forceReducerReload(store) {\n  store.replaceReducer(store.createReducer(store.injectedReducers));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n/**\n * Validates the redux store is set up properly to work with this library.\n */\n\n\nfunction checkStore(store) {\n  var shape = {\n    dispatch: isFunction,\n    subscribe: isFunction,\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    createReducer: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject\n  };\n  invariant(conformsTo(store, shape), '(redux-injectors...) checkStore: Expected a redux store that has been configured for use with redux-injectors.');\n}\n\nfunction injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n    invariant(isString(key) && !isEmpty(key) && isFunction(reducer), '(redux-injectors...) injectReducer: Expected `reducer` to be a reducer function'); // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n\n    if (Reflect.has(store.injectedReducers, key) && store.injectedReducers[key] === reducer) return;\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n\n    store.replaceReducer(store.createReducer(store.injectedReducers));\n  };\n}\n\nfunction getInjectors(store) {\n  checkStore(store);\n  return {\n    injectReducer: injectReducerFactory(store, true)\n  };\n}\n/**\n * A higher-order component that dynamically injects a reducer when the\n * component is instantiated\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *   render() {\n *     return null;\n *   }\n * }\n *\n * export default injectReducer({ key: \"books\", reducer: booksReducer })(BooksManager)\n *\n * @public\n */\n\n\nvar injectReducer = function (_ref) {\n  var key = _ref.key,\n      reducer = _ref.reducer;\n  return function (WrappedComponent) {\n    var ReducerInjector = /*#__PURE__*/function (_React$Component) {\n      _inherits(ReducerInjector, _React$Component);\n\n      function ReducerInjector(props, context) {\n        var _this;\n\n        _classCallCheck(this, ReducerInjector);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ReducerInjector).call(this, props, context));\n        getInjectors(context.store).injectReducer(key, reducer);\n        return _this;\n      }\n\n      _createClass(ReducerInjector, [{\n        key: \"render\",\n        value: function render() {\n          return React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return ReducerInjector;\n    }(React.Component);\n\n    _defineProperty(ReducerInjector, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(ReducerInjector, \"contextType\", ReactReduxContext);\n\n    _defineProperty(ReducerInjector, \"displayName\", \"withReducer(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n  };\n};\n/**\n * A react hook that dynamically injects a reducer when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectReducer({ key: \"books\", reducer: booksReducer })\n *\n *   return null;\n * }\n *\n * @public\n */\n\n\nvar useInjectReducer = function useInjectReducer(_ref2) {\n  var key = _ref2.key,\n      reducer = _ref2.reducer;\n  var store = useStore();\n  var isInjected = React.useRef(false);\n\n  if (!isInjected.current) {\n    getInjectors(store).injectReducer(key, reducer);\n    isInjected.current = true;\n  }\n};\n\nvar RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nvar DAEMON = '@@saga-injector/daemon';\nvar ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\n/**\n * An enum of all the possible saga injection behaviours\n *\n * @property {String} RESTART_ON_REMOUNT The saga will be started on component instantiation and cancelled with\n * `task.cancel()` on component unmount for improved performance.\n * @property {String} DAEMON Causes the saga to be started on component instantiation and never canceled\n * or started again.\n * @property {String} ONCE_TILL_UNMOUNT Behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n * @enum\n * @public\n */\n\nvar SagaInjectionModes = {\n  RESTART_ON_REMOUNT: RESTART_ON_REMOUNT,\n  DAEMON: DAEMON,\n  ONCE_TILL_UNMOUNT: ONCE_TILL_UNMOUNT\n};\nvar allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nvar checkKey = function checkKey(key) {\n  return invariant(isString(key) && !isEmpty(key), '(redux-injectors...) injectSaga: Expected `key` to be a non empty string');\n};\n\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: isFunction,\n    mode: function mode(_mode) {\n      return isString(_mode) && allowedModes.includes(_mode);\n    }\n  };\n  invariant(conformsTo(descriptor, shape), '(redux-injectors...) injectSaga: Expected a valid saga descriptor');\n};\n\nfunction injectSagaFactory(store, isValid) {\n  return function injectSaga(key) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isValid) checkStore(store);\n\n    var newDescriptor = _objectSpread2({}, descriptor, {\n      mode: descriptor.mode || DAEMON\n    });\n\n    var saga = newDescriptor.saga,\n        mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = _objectSpread2({}, newDescriptor, {\n        task: store.runSaga(saga)\n      });\n      /* eslint-enable no-param-reassign */\n    }\n  };\n}\n\nfunction ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nfunction getInjectors$1(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}\n/**\n * A higher-order component that dynamically injects a saga when the component\n * is instantiated. There are several possible \"modes\" / \"behaviours\" that\n * dictate how and when the saga should be injected and ejected\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *  render() {\n *    return null;\n *  }\n * }\n *\n * export default injectSaga({ key: \"books\", saga: booksSaga })(BooksManager)\n *\n * @public\n *\n */\n\n\nvar injectSaga = function (_ref) {\n  var key = _ref.key,\n      saga = _ref.saga,\n      mode = _ref.mode;\n  return function (WrappedComponent) {\n    var InjectSaga = /*#__PURE__*/function (_React$Component) {\n      _inherits(InjectSaga, _React$Component);\n\n      function InjectSaga(props, context) {\n        var _this;\n\n        _classCallCheck(this, InjectSaga);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(InjectSaga).call(this, props, context));\n        _this.injectors = getInjectors$1(context.store);\n\n        _this.injectors.injectSaga(key, {\n          saga: saga,\n          mode: mode\n        });\n\n        return _this;\n      }\n\n      _createClass(InjectSaga, [{\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.injectors.ejectSaga(key);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return InjectSaga;\n    }(React.Component);\n\n    _defineProperty(InjectSaga, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(InjectSaga, \"contextType\", ReactReduxContext);\n\n    _defineProperty(InjectSaga, \"displayName\", \"withSaga(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(InjectSaga, WrappedComponent);\n  };\n};\n/**\n * A react hook that dynamically injects a saga when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectSaga({ key: \"books\", saga: booksSaga })\n *\n *   return null;\n * }\n *\n * @public\n */\n\n\nvar useInjectSaga = function useInjectSaga(_ref2) {\n  var key = _ref2.key,\n      saga = _ref2.saga,\n      mode = _ref2.mode;\n  var store = useStore();\n  var isInjected = React.useRef(false);\n\n  if (!isInjected.current) {\n    getInjectors$1(store).injectSaga(key, {\n      saga: saga,\n      mode: mode\n    });\n    isInjected.current = true;\n  }\n\n  React.useEffect(function () {\n    return function () {\n      getInjectors$1(store).ejectSaga(key);\n    };\n  }, []);\n};\n/**\n * Creates a store enhancer that when applied will setup the store to allow the\n * injectors to work properly\n *\n * @param {Object} params\n * @param {function} params.runSaga A function that runs a saga. Should usually be `sagaMiddleware.run`\n * @param {function} params.createReducer A function that should create and\n * return the root reducer. It's passed the injected reducers as the first\n * parameter. These should be added to the root reducer using `combineReducer`\n * or a similar method.\n *\n * @example\n *\n * import { createStore } from \"redux\"\n * import { createInjectorsEnhancer } from \"redux-injectors\"\n *\n * function createReducer(injectedReducers = {}) {\n *  const rootReducer = combineReducers({\n *    ...injectedReducers,\n *    // other non-injected reducers can go here...\n *  });\n *\n *  return rootReducer\n * }\n * const runSaga = sagaMiddleware.run\n *\n * const store = createStore(\n *   createReducer(),\n *   initialState,\n *   createInjectorsEnhancer({\n *     createReducer,\n *     runSaga,\n *   })\n * )\n *\n * @public\n */\n\n\nfunction createInjectorsEnhancer(params) {\n  invariant(conformsTo(params, {\n    runSaga: isFunction,\n    createReducer: isFunction\n  }), '(redux-injectors...) createInjectorsEnhancer: params `runSaga` and ' + '`createReducer` are required.');\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n      return _objectSpread2({}, store, {\n        createReducer: params.createReducer,\n        runSaga: params.runSaga,\n        injectedReducers: {},\n        // Reducer registry\n        injectedSagas: {} // Saga registry\n\n      });\n    };\n  };\n}\n\nexport { SagaInjectionModes, createInjectorsEnhancer, forceReducerReload, injectReducer, injectSaga, useInjectReducer, useInjectSaga };","map":{"version":3,"sources":["/home/mohamed/Desktop/projects/oxycare/node_modules/redux-injectors/dist/index.esm.js"],"names":["React","hoistNonReactStatics","ReactReduxContext","useStore","invariant","isEmpty","isFunction","isString","conformsTo","isObject","forceReducerReload","store","replaceReducer","createReducer","injectedReducers","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_inherits","subClass","superClass","create","constructor","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","call","checkStore","shape","dispatch","subscribe","getState","runSaga","injectedSagas","injectReducerFactory","isValid","injectReducer","reducer","Reflect","has","getInjectors","_ref","WrappedComponent","ReducerInjector","_React$Component","context","_this","render","createElement","Component","concat","displayName","name","useInjectReducer","_ref2","isInjected","useRef","current","RESTART_ON_REMOUNT","DAEMON","ONCE_TILL_UNMOUNT","SagaInjectionModes","allowedModes","checkKey","checkDescriptor","saga","mode","_mode","includes","injectSagaFactory","injectSaga","undefined","newDescriptor","hasSaga","process","env","NODE_ENV","oldDescriptor","task","cancel","ejectSagaFactory","ejectSaga","getInjectors$1","InjectSaga","injectors","componentWillUnmount","useInjectSaga","useEffect","createInjectorsEnhancer","params","createStore"],"mappings":"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","sourcesContent":["import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext, useStore } from 'react-redux';\nimport invariant from 'invariant';\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport conformsTo from 'lodash/conformsTo';\nimport isObject from 'lodash/isObject';\n\n/**\n * Forces a reload of the injected reducers. i.e. Causes `createReducer` to be\n * called again with the injected reducers. Useful for hot-reloading.\n *\n * @param store The redux store that has been configured with\n *                  `createInjectorsEnhancer`\n * @example\n * forceReducerReload(store);\n *\n * @public\n */\nfunction forceReducerReload(store) {\n  store.replaceReducer(store.createReducer(store.injectedReducers));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\n/**\n * Validates the redux store is set up properly to work with this library.\n */\n\nfunction checkStore(store) {\n  var shape = {\n    dispatch: isFunction,\n    subscribe: isFunction,\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    createReducer: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject\n  };\n  invariant(conformsTo(store, shape), '(redux-injectors...) checkStore: Expected a redux store that has been configured for use with redux-injectors.');\n}\n\nfunction injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n    invariant(isString(key) && !isEmpty(key) && isFunction(reducer), '(redux-injectors...) injectReducer: Expected `reducer` to be a reducer function'); // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n\n    if (Reflect.has(store.injectedReducers, key) && store.injectedReducers[key] === reducer) return;\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n\n    store.replaceReducer(store.createReducer(store.injectedReducers));\n  };\n}\nfunction getInjectors(store) {\n  checkStore(store);\n  return {\n    injectReducer: injectReducerFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a reducer when the\n * component is instantiated\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *   render() {\n *     return null;\n *   }\n * }\n *\n * export default injectReducer({ key: \"books\", reducer: booksReducer })(BooksManager)\n *\n * @public\n */\n\nvar injectReducer = (function (_ref) {\n  var key = _ref.key,\n      reducer = _ref.reducer;\n  return function (WrappedComponent) {\n    var ReducerInjector =\n    /*#__PURE__*/\n    function (_React$Component) {\n      _inherits(ReducerInjector, _React$Component);\n\n      function ReducerInjector(props, context) {\n        var _this;\n\n        _classCallCheck(this, ReducerInjector);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ReducerInjector).call(this, props, context));\n        getInjectors(context.store).injectReducer(key, reducer);\n        return _this;\n      }\n\n      _createClass(ReducerInjector, [{\n        key: \"render\",\n        value: function render() {\n          return React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return ReducerInjector;\n    }(React.Component);\n\n    _defineProperty(ReducerInjector, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(ReducerInjector, \"contextType\", ReactReduxContext);\n\n    _defineProperty(ReducerInjector, \"displayName\", \"withReducer(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n  };\n});\n/**\n * A react hook that dynamically injects a reducer when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the reducer under\n * @param {function} params.reducer The reducer that will be injected\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectReducer({ key: \"books\", reducer: booksReducer })\n *\n *   return null;\n * }\n *\n * @public\n */\n\nvar useInjectReducer = function useInjectReducer(_ref2) {\n  var key = _ref2.key,\n      reducer = _ref2.reducer;\n  var store = useStore();\n  var isInjected = React.useRef(false);\n\n  if (!isInjected.current) {\n    getInjectors(store).injectReducer(key, reducer);\n    isInjected.current = true;\n  }\n};\n\nvar RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nvar DAEMON = '@@saga-injector/daemon';\nvar ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\n/**\n * An enum of all the possible saga injection behaviours\n *\n * @property {String} RESTART_ON_REMOUNT The saga will be started on component instantiation and cancelled with\n * `task.cancel()` on component unmount for improved performance.\n * @property {String} DAEMON Causes the saga to be started on component instantiation and never canceled\n * or started again.\n * @property {String} ONCE_TILL_UNMOUNT Behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n * @enum\n * @public\n */\n\nvar SagaInjectionModes = {\n  RESTART_ON_REMOUNT: RESTART_ON_REMOUNT,\n  DAEMON: DAEMON,\n  ONCE_TILL_UNMOUNT: ONCE_TILL_UNMOUNT\n};\n\nvar allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nvar checkKey = function checkKey(key) {\n  return invariant(isString(key) && !isEmpty(key), '(redux-injectors...) injectSaga: Expected `key` to be a non empty string');\n};\n\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: isFunction,\n    mode: function mode(_mode) {\n      return isString(_mode) && allowedModes.includes(_mode);\n    }\n  };\n  invariant(conformsTo(descriptor, shape), '(redux-injectors...) injectSaga: Expected a valid saga descriptor');\n};\n\nfunction injectSagaFactory(store, isValid) {\n  return function injectSaga(key) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isValid) checkStore(store);\n\n    var newDescriptor = _objectSpread2({}, descriptor, {\n      mode: descriptor.mode || DAEMON\n    });\n\n    var saga = newDescriptor.saga,\n        mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = _objectSpread2({}, newDescriptor, {\n        task: store.runSaga(saga)\n      });\n      /* eslint-enable no-param-reassign */\n    }\n  };\n}\nfunction ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\nfunction getInjectors$1(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}\n\n/**\n * A higher-order component that dynamically injects a saga when the component\n * is instantiated. There are several possible \"modes\" / \"behaviours\" that\n * dictate how and when the saga should be injected and ejected\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * class BooksManager extends React.PureComponent {\n *  render() {\n *    return null;\n *  }\n * }\n *\n * export default injectSaga({ key: \"books\", saga: booksSaga })(BooksManager)\n *\n * @public\n *\n */\n\nvar injectSaga = (function (_ref) {\n  var key = _ref.key,\n      saga = _ref.saga,\n      mode = _ref.mode;\n  return function (WrappedComponent) {\n    var InjectSaga =\n    /*#__PURE__*/\n    function (_React$Component) {\n      _inherits(InjectSaga, _React$Component);\n\n      function InjectSaga(props, context) {\n        var _this;\n\n        _classCallCheck(this, InjectSaga);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(InjectSaga).call(this, props, context));\n        _this.injectors = getInjectors$1(context.store);\n\n        _this.injectors.injectSaga(key, {\n          saga: saga,\n          mode: mode\n        });\n\n        return _this;\n      }\n\n      _createClass(InjectSaga, [{\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.injectors.ejectSaga(key);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return React.createElement(WrappedComponent, this.props);\n        }\n      }]);\n\n      return InjectSaga;\n    }(React.Component);\n\n    _defineProperty(InjectSaga, \"WrappedComponent\", WrappedComponent);\n\n    _defineProperty(InjectSaga, \"contextType\", ReactReduxContext);\n\n    _defineProperty(InjectSaga, \"displayName\", \"withSaga(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n\n    return hoistNonReactStatics(InjectSaga, WrappedComponent);\n  };\n});\n/**\n * A react hook that dynamically injects a saga when the hook is run\n *\n * @param {Object} params\n * @param {string} params.key The key to inject the saga under\n * @param {function} params.saga The saga that will be injected\n * @param {string} [params.mode] The injection behaviour to use. The default is\n * `SagaInjectionModes.DAEMON` which causes the saga to be started on component\n * instantiation and never canceled or started again. @see\n * {@link SagaInjectionModes} for the other possible modes.\n *\n * @example\n *\n * function BooksManager() {\n *   useInjectSaga({ key: \"books\", saga: booksSaga })\n *\n *   return null;\n * }\n *\n * @public\n */\n\nvar useInjectSaga = function useInjectSaga(_ref2) {\n  var key = _ref2.key,\n      saga = _ref2.saga,\n      mode = _ref2.mode;\n  var store = useStore();\n  var isInjected = React.useRef(false);\n\n  if (!isInjected.current) {\n    getInjectors$1(store).injectSaga(key, {\n      saga: saga,\n      mode: mode\n    });\n    isInjected.current = true;\n  }\n\n  React.useEffect(function () {\n    return function () {\n      getInjectors$1(store).ejectSaga(key);\n    };\n  }, []);\n};\n\n/**\n * Creates a store enhancer that when applied will setup the store to allow the\n * injectors to work properly\n *\n * @param {Object} params\n * @param {function} params.runSaga A function that runs a saga. Should usually be `sagaMiddleware.run`\n * @param {function} params.createReducer A function that should create and\n * return the root reducer. It's passed the injected reducers as the first\n * parameter. These should be added to the root reducer using `combineReducer`\n * or a similar method.\n *\n * @example\n *\n * import { createStore } from \"redux\"\n * import { createInjectorsEnhancer } from \"redux-injectors\"\n *\n * function createReducer(injectedReducers = {}) {\n *  const rootReducer = combineReducers({\n *    ...injectedReducers,\n *    // other non-injected reducers can go here...\n *  });\n *\n *  return rootReducer\n * }\n * const runSaga = sagaMiddleware.run\n *\n * const store = createStore(\n *   createReducer(),\n *   initialState,\n *   createInjectorsEnhancer({\n *     createReducer,\n *     runSaga,\n *   })\n * )\n *\n * @public\n */\n\nfunction createInjectorsEnhancer(params) {\n  invariant(conformsTo(params, {\n    runSaga: isFunction,\n    createReducer: isFunction\n  }), '(redux-injectors...) createInjectorsEnhancer: params `runSaga` and ' + '`createReducer` are required.');\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n      return _objectSpread2({}, store, {\n        createReducer: params.createReducer,\n        runSaga: params.runSaga,\n        injectedReducers: {},\n        // Reducer registry\n        injectedSagas: {} // Saga registry\n\n      });\n    };\n  };\n}\n\nexport { SagaInjectionModes, createInjectorsEnhancer, forceReducerReload, injectReducer, injectSaga, useInjectReducer, useInjectSaga };\n"]},"metadata":{},"sourceType":"module"}